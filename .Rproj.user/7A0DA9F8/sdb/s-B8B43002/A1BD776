{
    "contents" : "\nprocessSlots <- function(slotsAnnualize, rdf, rdfName, traceSpace)\n{\n\tann <- slotsAnnualize[2]\n\tthresh <- as.numeric(slotsAnnualize[3])\n\tthresh[is.na(thresh)] = 1 # can use thresh as a scale also.  If it is not specified,\n\t# then multiply by 1.\n\tslot <- slotsAnnualize[1]\n\n\tif(!(slot %in% listSlots(rdf))){\n\t\tstop(paste(\"slot:\", slot, \"not found in rdf:\", rdfName))\n\t}\n\tslot <- rdfSlotToMatrix(rdf, slot)\n\t\n\tstartData <- strsplit(rdf$runs[[1]]$start, '-')[[1]]\n\tendData <- strsplit(rdf$runs[[1]]$end, '-')[[1]]\n\n\tyy <- seq(as.numeric(startData[1]), as.numeric(endData[1]), 1)\n\t\n\t# XXX\n\t# Need to add other summerization methods to this area\n\t# XXX\n\t# now summarize in some way\n\tif(ann == 'AnnMin'){\n\t\tslot <- apply(slot, 2, returnMinAnn) # minimum annual value\n\t\trownames(slot) <- yy\n\t} else if(ann == 'EOCY'){\n\t\tslot <- slot[seq(12, nrow(slot), 12),] \n\t\tslot[is.nan(slot)] <- 0\n\t\tslot <- slot * thresh\n\t\trownames(slot) <- yy\n\t} else if(ann == 'AnnMax'){\n\t\tslot <- apply(slot, 2, returnMaxAnn) # minimum annual value\n\t\trownames(slot) <- yy\n\t} else if(ann == 'AnnualSum'){\n\t\tslot <- sumMonth2Annual(slot,thresh)\n\t\trownames(slot) <- yy\n\t} else if(ann == 'AnnMinLTE'){\n\t\tslot <- apply(slot, 2, returnMinAnn) # minimum annual value\n\t\tslot[slot <= thresh] <- 1\n\t\tslot[slot > thresh] <- 0\n\t\tslot <- slot * 100\n\t\trownames(slot) <- yy\n\t} else if(ann == 'Monthly'){\n\t\t# XXX\n\t\t# need to update to use time series from zoo library\n\t\tyy <- matrix(t(matrix(rep(yy, 12),ncol = 12, byrow = F)), ncol = 1, byrow = F)\n\t\trownames(slot) <- paste(rep(month.abb, nrow(slot)/12),yy,sep = '-')\n\t\tslot <- slot*thresh\n\t} else if(ann == 'WYMinLTE'){\n\t\tslot <- rbind(slot[1,],slot[1,],slot[1,],slot)\n\t\tslot <- slot[1:(nrow(slot)-3),]\n\t\tslot <- apply(slot, 2, returnMinAnn) # minimum annual value\n\t\tslot[slot <= thresh] <- 1\n\t\tslot[slot > thresh] <- 0\n\t\tslot <- slot * 100\n\t\trownames(slot) <- yy\n\t} else{\n\t\tstop('invalid ann variable')\n\t}\n\t\n\tif(traceSpace){\n\t\tcolnames(slot) <- paste('Trace',1:ncol(slot))\n\t} else{\n\t\tcolnames(slot) <- paste('Trace',1:ncol(slot),sep = '')\n\t}\n\tif(ann != 'Monthly'){\n\t\tslot <- melt(slot, value.name = 'Value', varnames = c('Year','Trace'))\n\t\tslot <- cbind(slot, rep(paste(slotsAnnualize[1],ann,thresh,sep = '_'),nrow(slot)))\n\t\tcolnames(slot)[ncol(slot)] <- 'Variable'\n\t\tslot <- subset(slot,select = c(Trace, Year, Variable, Value))\n\t} else{\n\t\tslot <- melt(slot, value.name = 'Value', varnames = c('Month','Trace'))\n\t\tmm <- simplify2array(strsplit(as.character(slot$Month), '-'))\n\t\tslot$Month <- mm[1,]\n\t\tslot$Variable <- rep(paste(slotsAnnualize[1],ann,thresh,sep = '_'),nrow(slot))\n\t\tslot$Year <- mm[2,]\n\t\t#colnames(slot)[(ncol(slot)-1):ncol(slot)] <- c('Variable','Year')\n\t\tslot <- subset(slot,select = c(Trace, Month, Year, Variable, Value))\n\t}\n\tslot\n}\n\ngetSlots <- function(slotsAndRdf, scenPath, traceSpace)\n{\n\tslotsAnnualize <- rbind(slotsAndRdf$slots, slotsAndRdf$annualize)\n\trdf <- slotsAndRdf$rdf\n\trdf <- read.rdf(paste(scenPath,'/',rdf,sep = ''))\n\n\t#print(paste('padding first three months of',slot,\n\t\t\t#'with January data to make Water Year based computation.\\nPlease ensure this is an appropriate assumption'))\n\t#flush.console()\n\tallSlots <- apply(slotsAnnualize, 2, processSlots, rdf, slotsAndRdf$rdf, traceSpace)\n\tallSlots <- do.call(rbind, lapply(allSlots, function(X) X))\n\tallSlots\n}\n\ngetAndProcessAllSlots <- function(scenPath, slotsAndRdf, tags, traceSpace)\n{\n\tsPath <- scenPath[1]\n\tsName <- scenPath[2]\n\tzz <- lapply(slotsAndRdf, getSlots, sPath, traceSpace)\n\n\tallRes <- do.call(rbind, lapply(zz, function(X) X))\n\tnn = colnames(allRes)\n\n\tallRes$Scenario <- rep(sName, nrow(allRes))\n\tallRes <- subset(allRes, select=c('Scenario', nn))\n\t# tag for drought contingency modeling\n\tif(tags == 'DCP'){\n\t\tscenFull <- strsplit(sPath,'/')[[1]]\n\t\tscenFull <- scenFull[length(scenFull)]\n\t\t\n\t\tdryOrWet15 <- readDryWetFile(scenFull, '15To19')\n\t\tdryOrWet20 <-readDryWetFile(scenFull, '20To26')\n\t\tvulnT <- readVulnFile(scenFull)\n\t\td15 <- match(allRes$Trace, names(dryOrWet15))\n\t\td15 <- dryOrWet15[d15]\n\t\td20 <- match(allRes$Trace, names(dryOrWet20))\n\t\td20 <- dryOrWet20[d20]\n\t\tvv <- match(allRes$Trace, names(vulnT))\n\t\tvv <- vulnT[vv]\n\n\t\tallRes$DryOrWet2015To2019 <- simplify2array(d15)\n\t\tallRes$DryOrWet2020To2026 <- simplify2array(d20)\n\t\tallRes$VulnTrace <- simplify2array(vv)\n\t\t\n\t\t# create a separate column for supply, one for Scenario, and one for hyd-Scenario\n\t\ttmp <- as.character(allRes$Scenario)\n\t\tallRes$Hyd_Scen <- allRes$Scenario\n\t\tonlyScen <- getScenNoSupply(scenFull)\n\t\tonlyHyd <- getScenHydrology(scenFull)\n\t\tallRes$Scenario <- rep(onlyScen, nrow(allRes))\n\t\tallRes$Hydrology <- rep(onlyHyd, nrow(allRes))\n\t}\n\tallRes\n}\n\ngetDataForAllScens <- function(scenFolders, scenNames, slotsAndRdf, scenPath, oFile, \n\ttags = '', traceSpace = TRUE)\n{\n\n\tscenPath = paste(scenPath,'/',scenFolders,sep = '')\n\tscen = cbind(scenPath, scenNames)\n\tzz = apply(scen, 1, getAndProcessAllSlots, slotsAndRdf, tags, traceSpace)\n\tzz <- do.call(rbind, lapply(zz, function(X) X))\n\t\n\twrite.table(as.matrix(zz), oFile, row.names = F, sep = '\\t')\n}\n\n# takes an existing data file, and edits it\nchangeDataFile <- function(iFile, varName, newVarName = varName, oldVals, newVals)\n{\n\tzz = read.table(iFile, header = T)\n\ttmp = as.matrix(subset(zz, select = varName))\n\tfor(i in 1:length(oldVals)){\n\t\ttmp[tmp == oldVals[i]] = newVals[i]\n\t}\n\n\tii = match(varName, colnames(zz))\n\tcolnames(zz)[ii] = newVarName\n\tzz[,ii] = tmp\n\twrite.table(as.matrix(zz), iFile, row.names = F, sep = '\\t')\n} ",
    "created" : 1410902464698.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2020535300",
    "id" : "A1BD776",
    "lastKnownWriteTime" : 1410902568,
    "path" : "C:/alan/RPackages/RWDataPlot/R/getDataFromRdf.R",
    "project_path" : "R/getDataFromRdf.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}